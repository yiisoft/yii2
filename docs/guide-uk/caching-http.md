HTTP кешування
============

Крім серверного кешування, яке ми описали в попередніх розділах, веб-додатки також можуть використовувати кешування на стороні клієнта, щоб заощадити час для формування та передачі одного і того ж змісту сторінки.

Щоб використовувати кешування на стороні клієнта, ви можете налаштувати [[yii\filters\HttpCache]] в якості фільтра для дії контролера, що відображає результат, який може бути закешований на стороні клієнта. [[yii\filters\HttpCache|HttpCache]] працює тільки для `GET` та `HEAD` запитів. Для цих запитів він може обробляти три види HTTP заголовків, що відносяться до кешування:

* [[yii\filters\HttpCache::lastModified|Last-Modified]]
* [[yii\filters\HttpCache::etagSeed|Etag]]
* [[yii\filters\HttpCache::cacheControlHeader|Cache-Control]]


## Заголовок `Last-Modified` <a name="last-modified"></a>

Заголовок `Last-Modified` використовує часову позначку timestamp, щоб показати чи була сторінка змінена після того, як клієнт закешував її.

Ви можете налаштувати властивість [[yii\filters\HttpCache::lastModified]], щоб увімкнути відправку заголовка `Last-Modified`. Властивість повинна містити PHP-функцію, що повертає часову мітку UNIX timestamp часу останньої зміни сторінки. Сигнатура PHP-функції повинна збігатися з наступною

```php
/**
 * @param Action $action объект действия, которое в настоящее время обрабатывается
 * @param array $params значение свойства "params"
 * @return integer временная метка UNIX timestamp, возвращающая время последнего изменения страницы
 */
function ($action, $params)
```

Нижче наведено приклад використання заголовка `Last-Modified`:

```php
public function behaviors()
{
    return [
        [
            'class' => 'yii\filters\HttpCache',
            'only' => ['index'],
            'lastModified' => function ($action, $params) {
                $q = new \yii\db\Query();
                return $q->from('post')->max('updated_at');
            },
        ],
    ];
}
```

Наведений вище код встановлює, що HTTP кешування повинно бути включено тільки для дії `index`. Він 
генерує `Last-Modified` HTTP заголовок на підставі часу останнього повідомлення. Коли браузер в перший раз відвідує сторінку `index`, то сторінка буде згенеровано на сервері і відправлена в браузер; якщо браузер знову зайде на цю сторінку і з того часу жоден пост не оновиться, то сервер не буде перестворювати сторінку і браузер буде використовувати закешовану на стороні клієнта версію. В результаті, буде пропущено як створення сторінки на стороні сервера, так і передача змісту сторінки клієнту.


## Заголовок `ETag` <a name="etag"></a>

Заголовок "Entity Tag" (або коротко `ETag`) використовується для передачі хеша змісту сторінки. Якщо сторінка була змінена, то хеш сторінки теж зміниться. Порівнюючи хеш на стороні клієнта з хешем, що генерується на стороні сервера, кеш може визначити, чи була станиця змінена і чи потрібно її передавати заново.

Вы можете налаштувати властивість [[yii\filters\HttpCache::etagSeed]], щоб увімкнути передачу заголовку `ETag`. Властивість повинна містити PHP-функцію, що повертає seed для генерації ETag хеша. Сигнатура PHP-функції повинна збігатися з наступною,

```php
/**
 * @param Action $action об'єкт дії, яка в даний час обробляється
 * @param array $params значення властивості "params"
 * @return string рядок, що використовується як seed для генерації ETag хеша
 */
function ($action, $params)
```

Нижче наведено приклад використання заголовка `ETag`:

```php
public function behaviors()
{
    return [
        [
            'class' => 'yii\filters\HttpCache',
            'only' => ['view'],
            'etagSeed' => function ($action, $params) {
                $post = $this->findModel(\Yii::$app->request->get('id'));
                return serialize([$post->title, $post->content]);
            },
        ],
    ];
}
```

Наведений вище код встановлює, що HTTP кешування повинно бути увімкнено тільки для дії `view`. він
генерує `ETag` HTTP заголовок на підставі заголовка та змісту останнього повідомлення. Коли браузер в перший раз відвідує сторінку `view`, то сторінка буде згенерована на сервері і відправлена в браузер; якщо браузер знову зайде на цю сторінку і з тих пір жоден пост не оновиться, то сервер не буде перестворювати сторінку і браузер буде використовувати закешовану на стороні клієнта версію. В результаті, буде пропущено як створення сторінки на стороні сервера, так і передача змісту сторінки клієнту.

ETags дозволяє застосовувати більш складні і / або більш точні стратегії кешування, ніж заголовок `Last-Modified`.
Наприклад, ETag стане невалідним (некоректним), якщо на сайті була включена інша тема

Ресурсномістка генерація ETag може суперечити меті використання `HttpCache` і внести зайве навантаження,
т.к. він повинен пересоздавать при кожному запиті. Спробуйте знайти просте вираз, який інвалідірует кеш, якщо зміст сторінки було змінено.

> Примітка: У відповідності до [RFC 7232](http://tools.ietf.org/html/rfc7232#section-2.4),
  `HttpCache` біде відправлятись як `ETag` заголовок, так і `Last-Modified` заголовок, якщо вони обидва були налаштовані.
  І якщо клієнт відправляє як `If-None-Match` заголовок, так і `If-Modified-Since` заголовок, то перший з них буде прийнятий.


## Заголовок `Cache-Control` <a name="cache-control"></a>

Заголовок `Cache-Control` определяет общую политику кэширования страниц. Вы можете включить его отправку, настроив свойство [[yii\filters\HttpCache::cacheControlHeader]]. По-умолчанию будет отправлен следующий заголовок:

```
Cache-Control: public, max-age=3600
```

## Ограничитель кэша сессий <a name="session-cache-limiter"></a>

Когда на странице используются сессии, PHP автоматически отправляет некоторые связанные с кэшем HTTP заголовки, определённые в настройке `session.cache_limiter` в php.ini. Эти заголовки могут вмешиваться или отключать кэширование, которое вы ожидаете от `HttpCache`. Чтобы предотвратить эту проблему, по умолчанию `HttpCache` будет автоматически отключать отправку этих заголовков. Если вы хотите изменить это поведение, вы должны настроить свойство [[yii\filters\HttpCache::sessionCacheLimiter]]. Это свойство может принимать строковое значение, включая `public`, `private`, `private_no_expire` и `nocache`. Пожалуйста, обратитесь к руководству PHP о [session_cache_limiter()](http://www.php.net/manual/en/function.session-cache-limiter.php)
для объяснения этих значений.


## SEO подтекст <a name="seo-implications"></a>

Поисковые боты, как правило, с уважением относятся к заголовкам кэширования. Поскольку некоторые из поисковых систем имеют ограничение на количество страниц для одного домена, которые они обрабатывают в течение определенного промежутка времени, то предоставление заголовков кэширования может помочь индексации, поскольку будет уменьшено число обрабатываемых страниц.
