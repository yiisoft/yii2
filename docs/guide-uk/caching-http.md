HTTP кешування
============

Крім серверного кешування, яке ми описали в попередніх розділах, веб-додатки також можуть використовувати кешування на стороні клієнта, щоб заощадити час для формування та передачі одного і того ж змісту сторінки.

Щоб використовувати кешування на стороні клієнта, ви можете налаштувати [[yii\filters\HttpCache]] в якості фільтра для дії контролера, що відображає результат, який може бути закешований на стороні клієнта. [[yii\filters\HttpCache|HttpCache]] працює тільки для `GET` та `HEAD` запитів. Для цих запитів він може обробляти три види HTTP заголовків, що відносяться до кешування:

* [[yii\filters\HttpCache::lastModified|Last-Modified]]
* [[yii\filters\HttpCache::etagSeed|Etag]]
* [[yii\filters\HttpCache::cacheControlHeader|Cache-Control]]


## Заголовок `Last-Modified` <a name="last-modified"></a>

Заголовок `Last-Modified` використовує часову позначку timestamp, щоб показати чи була сторінка змінена після того, як клієнт закешував її.

Ви можете налаштувати властивість [[yii\filters\HttpCache::lastModified]], щоб увімкнути відправку заголовка `Last-Modified`. Властивість повинна містити PHP-функцію, що повертає часову мітку UNIX timestamp часу останньої зміни сторінки. Сигнатура PHP-функції повинна збігатися з наступною

```php
/**
 * @param Action $action об'єкт дії, яка в даний час обробляється
 * @param array $params значення властивості "params"
 * @return integer часова мітка UNIX timestamp, що повертає час останньої зміни сторінки
 */
function ($action, $params)
```

Нижче наведено приклад використання заголовка `Last-Modified`:

```php
public function behaviors()
{
    return [
        [
            'class' => 'yii\filters\HttpCache',
            'only' => ['index'],
            'lastModified' => function ($action, $params) {
                $q = new \yii\db\Query();
                return $q->from('post')->max('updated_at');
            },
        ],
    ];
}
```

Наведений вище код встановлює, що HTTP кешування повинно бути включено тільки для дії `index`. Він 
генерує `Last-Modified` HTTP заголовок на підставі часу останнього повідомлення. Коли браузер в перший раз відвідує сторінку `index`, то сторінка буде згенеровано на сервері і відправлена в браузер; якщо браузер знову зайде на цю сторінку і з того часу жоден пост не оновиться, то сервер не буде перестворювати сторінку і браузер буде використовувати закешовану на стороні клієнта версію. В результаті, буде пропущено як створення сторінки на стороні сервера, так і передача змісту сторінки клієнту.


## Заголовок `ETag` <a name="etag"></a>

Заголовок "Entity Tag" (або коротко `ETag`) використовується для передачі хеша змісту сторінки. Якщо сторінка була змінена, то хеш сторінки теж зміниться. Порівнюючи хеш на стороні клієнта з хешем, що генерується на стороні сервера, кеш може визначити, чи була станиця змінена і чи потрібно її передавати заново.

Вы можете налаштувати властивість [[yii\filters\HttpCache::etagSeed]], щоб увімкнути передачу заголовку `ETag`. Властивість повинна містити PHP-функцію, що повертає seed для генерації ETag хеша. Сигнатура PHP-функції повинна збігатися з наступною,

```php
/**
 * @param Action $action об'єкт дії, яка в даний час обробляється
 * @param array $params значення властивості "params"
 * @return string рядок, що використовується як seed для генерації ETag хеша
 */
function ($action, $params)
```

Нижче наведено приклад використання заголовка `ETag`:

```php
public function behaviors()
{
    return [
        [
            'class' => 'yii\filters\HttpCache',
            'only' => ['view'],
            'etagSeed' => function ($action, $params) {
                $post = $this->findModel(\Yii::$app->request->get('id'));
                return serialize([$post->title, $post->content]);
            },
        ],
    ];
}
```

Наведений вище код встановлює, що HTTP кешування повинно бути увімкнено тільки для дії `view`. він
генерує `ETag` HTTP заголовок на підставі заголовка та змісту останнього повідомлення. Коли браузер в перший раз відвідує сторінку `view`, то сторінка буде згенерована на сервері і відправлена в браузер; якщо браузер знову зайде на цю сторінку і з тих пір жоден пост не оновиться, то сервер не буде перестворювати сторінку і браузер буде використовувати закешовану на стороні клієнта версію. В результаті, буде пропущено як створення сторінки на стороні сервера, так і передача змісту сторінки клієнту.

ETags дозволяє застосовувати більш складні і / або більш точні стратегії кешування, ніж заголовок `Last-Modified`.
Наприклад, ETag стане невалідним (некоректним), якщо на сайті була включена інша тема

Ресурсномістка генерація ETag може суперечити меті використання `HttpCache` і внести зайве навантаження,
т.к. він повинен пересоздавать при кожному запиті. Спробуйте знайти просте вираз, який інвалідірует кеш, якщо зміст сторінки було змінено.

> Примітка: У відповідності до [RFC 7232](http://tools.ietf.org/html/rfc7232#section-2.4),
  `HttpCache` біде відправлятись як `ETag` заголовок, так і `Last-Modified` заголовок, якщо вони обидва були налаштовані.
  І якщо клієнт відправляє як `If-None-Match` заголовок, так і `If-Modified-Since` заголовок, то перший з них буде прийнятий.


## Заголовок `Cache-Control` <a name="cache-control"></a>

Заголовок `Cache-Control` визначає загальну політику кешування сторінок. Ви можете вмикати його відправку, налаштував властивість [[yii \ filters \ HttpCache :: cacheControlHeader]]. За замовчуванням буде відправлений наступний заголовок:

```
Cache-Control: public, max-age=3600
```

## Обмежувач кеша сесій <a name="session-cache-limiter"></a>

Коли на сторінці використовуються сесії, PHP автоматично відправляє деякі пов'язані з кешем HTTP заголовки, визначені в налаштуванні `session.cache_limiter` в php.ini. Ці заголовки можуть втручатися або відключати кешування, яке ви очікуєте від `HttpCache`. Щоб запобігти цю проблему, за замовчуванням `HttpCache` буде автоматично відключати відправку цих заголовків. Якщо ви хочете змінити цю поведінку, ви повинні налаштувати властивість [[yii \ filters \ HttpCache :: sessionCacheLimiter]]. Ця властивість може приймати строкове значення, включаючи `public`,` private`, `private_no_expire` і` nocache`. Будь ласка, зверніться до керівництва PHP про [session_cache_limiter()](http://www.php.net/manual/en/function.session-cache-limiter.php)
для пояснення цих значень.



## SEO підтекст <a name="seo-implications"></a>

Пошукові боти, як правило, з повагою ставляться до заголовків кешування. Оскільки деякі з пошукових систем мають обмеження на кількість сторінок для одного домену, які вони обробляють протягом певного проміжку часу, то надання заголовків кешування може допомогти індексації, оскільки буде зменшено число оброблюваних сторінок.
