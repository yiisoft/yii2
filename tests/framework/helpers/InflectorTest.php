<?php
/**
 * @link http://www.yiiframework.com/
 * @copyright Copyright (c) 2008 Yii Software LLC
 * @license http://www.yiiframework.com/license/
 */

namespace yiiunit\framework\helpers;

use yii\helpers\Inflector;
use yiiunit\TestCase;

/**
 * @group helpers
 */
class InflectorTest extends TestCase
{
    protected function setUp()
    {
        parent::setUp();

        // destroy application, Helper must work without Yii::$app
        $this->destroyApplication();
    }

    public function testPluralize()
    {
        $testData = [
            'move' => 'moves',
            'foot' => 'feet',
            'child' => 'children',
            'human' => 'humans',
            'man' => 'men',
            'staff' => 'staff',
            'tooth' => 'teeth',
            'person' => 'people',
            'mouse' => 'mice',
            'touch' => 'touches',
            'hash' => 'hashes',
            'shelf' => 'shelves',
            'potato' => 'potatoes',
            'bus' => 'buses',
            'test' => 'tests',
            'car' => 'cars',
            'netherlands' => 'netherlands',
            'currency' => 'currencies',
        ];

        foreach ($testData as $testIn => $testOut) {
            $this->assertEquals($testOut, Inflector::pluralize($testIn));
            $this->assertEquals(ucfirst($testOut), ucfirst(Inflector::pluralize($testIn)));
        }
    }

    public function testSingularize()
    {
        $testData = [
            'moves' => 'move',
            'feet' => 'foot',
            'children' => 'child',
            'humans' => 'human',
            'men' => 'man',
            'staff' => 'staff',
            'teeth' => 'tooth',
            'people' => 'person',
            'mice' => 'mouse',
            'touches' => 'touch',
            'hashes' => 'hash',
            'shelves' => 'shelf',
            'potatoes' => 'potato',
            'buses' => 'bus',
            'tests' => 'test',
            'cars' => 'car',
            'Netherlands' => 'Netherlands',
            'currencies' => 'currency',
        ];
        foreach ($testData as $testIn => $testOut) {
            $this->assertEquals($testOut, Inflector::singularize($testIn));
            $this->assertEquals(ucfirst($testOut), ucfirst(Inflector::singularize($testIn)));
        }
    }

    public function testTitleize()
    {
        $this->assertEquals('Me my self and i', Inflector::titleize('MeMySelfAndI'));
        $this->assertEquals('Me My Self And I', Inflector::titleize('MeMySelfAndI', true));
        $this->assertEquals('–¢—Ä–µ–±–∞ –ë—ñ–ª—å—à–µ –¢–µ—Å—Ç—ñ–≤!', Inflector::titleize('–¢—Ä–µ–±–∞–ë—ñ–ª—å—à–µ–¢–µ—Å—Ç—ñ–≤!', true));
    }

    public function testCamelize()
    {
        $this->assertEquals('MeMySelfAndI', Inflector::camelize('me my_self-andI'));
        $this->assertEquals('QweQweEwq', Inflector::camelize('qwe qwe^ewq'));
        $this->assertEquals('–í—ñ–¥–æ–º–æ–©–æ–¢–µ—Å—Ç–∏–ó–±–µ—Ä—ñ–≥–∞—Ç—å–ù–∞—à—ñ–ù–ï–†–í–ò', Inflector::camelize('–í—ñ–¥–æ–º–æ, —â–æ —Ç–µ—Å—Ç–∏ –∑–±–µ—Ä—ñ–≥–∞—Ç—å –Ω–∞—à—ñ –ù–ï–†–í–ò! üôÉ'));
    }

    public function testUnderscore()
    {
        $this->assertEquals('me_my_self_and_i', Inflector::underscore('MeMySelfAndI'));
        $this->assertEquals('–∫–æ–∂–Ω–∏–π_—Ç–µ—Å—Ç_–æ—Å–æ–±–ª–∏–≤–∏–π', Inflector::underscore('–ö–æ–∂–Ω–∏–π–¢–µ—Å—Ç–û—Å–æ–±–ª–∏–≤–∏–π'));
    }

    public function testCamel2words()
    {
        $this->assertEquals('Camel Case', Inflector::camel2words('camelCase'));
        $this->assertEquals('Lower Case', Inflector::camel2words('lower_case'));
        $this->assertEquals('Tricky Stuff It Is Testing', Inflector::camel2words(' tricky_stuff.it-is testing... '));
        $this->assertEquals('–Ü –¶–µ –î—ñ–π—Å–Ω–æ –¢–∞–∫!', Inflector::camel2words('–Ü–¶–µ–î—ñ–π—Å–Ω–æ–¢–∞–∫!'));
    }

    public function testCamel2id()
    {
        $this->assertEquals('post-tag', Inflector::camel2id('PostTag'));
        $this->assertEquals('post_tag', Inflector::camel2id('PostTag', '_'));
        $this->assertEquals('—î–¥–∏–Ω–∏–π_–∫–æ–¥', Inflector::camel2id('–Ñ–¥–∏–Ω–∏–π–ö–æ–¥', '_'));

        $this->assertEquals('post-tag', Inflector::camel2id('postTag'));
        $this->assertEquals('post_tag', Inflector::camel2id('postTag', '_'));
        $this->assertEquals('—î–¥–∏–Ω–∏–π_–∫–æ–¥', Inflector::camel2id('—î–¥–∏–Ω–∏–π–ö–æ–¥', '_'));

        $this->assertEquals('foo-ybar', Inflector::camel2id('FooYBar', '-', false));
        $this->assertEquals('foo_ybar', Inflector::camel2id('fooYBar', '_', false));
        $this->assertEquals('–Ω–µ–≤–∂–µ_—ñ—Ü–µ_–ø—Ä–∞—Ü—é—î', Inflector::camel2id('–ù–µ–≤–∂–µ–Ü–¶–µ–ü—Ä–∞—Ü—é—î', '_', false));

        $this->assertEquals('foo-y-bar', Inflector::camel2id('FooYBar', '-', true));
        $this->assertEquals('foo_y_bar', Inflector::camel2id('fooYBar', '_', true));
        $this->assertEquals('foo_y_bar', Inflector::camel2id('fooYBar', '_', true));
        $this->assertEquals('–Ω–µ–≤–∂–µ_—ñ_—Ü–µ_–ø—Ä–∞—Ü—é—î', Inflector::camel2id('–ù–µ–≤–∂–µ–Ü–¶–µ–ü—Ä–∞—Ü—é—î', '_', true));
    }

    public function testId2camel()
    {
        $this->assertEquals('PostTag', Inflector::id2camel('post-tag'));
        $this->assertEquals('PostTag', Inflector::id2camel('post_tag', '_'));
        $this->assertEquals('–Ñ–¥–∏–Ω–∏–π–°–≤—ñ—Ç', Inflector::id2camel('—î–¥–∏–Ω–∏–π_—Å–≤—ñ—Ç', '_'));

        $this->assertEquals('PostTag', Inflector::id2camel('post-tag'));
        $this->assertEquals('PostTag', Inflector::id2camel('post_tag', '_'));
        $this->assertEquals('–ù–µ–≤–∂–µ–Ü–¶–µ–ü—Ä–∞—Ü—é—î', Inflector::id2camel('–Ω–µ–≤–∂–µ_—ñ_—Ü–µ_–ø—Ä–∞—Ü—é—î', '_'));

        $this->assertEquals('ShouldNotBecomeLowercased', Inflector::id2camel('ShouldNotBecomeLowercased', '_'));

        $this->assertEquals('FooYBar', Inflector::id2camel('foo-y-bar'));
        $this->assertEquals('FooYBar', Inflector::id2camel('foo_y_bar', '_'));
    }

    public function testHumanize()
    {
        $this->assertEquals('Me my self and i', Inflector::humanize('me_my_self_and_i'));
        $this->assertEquals('Me My Self And I', Inflector::humanize('me_my_self_and_i', true));
        $this->assertEquals('–ê–ª–µ –π –≤–µ—Å–µ–ª—ñ —Ü—ñ –≤–∞—à—ñ —Ç–µ—Å—Ç–∏', Inflector::humanize('–∞–ª–µ_–π_–≤–µ—Å–µ–ª—ñ_—Ü—ñ_–≤–∞—à—ñ_—Ç–µ—Å—Ç–∏'));
    }

    public function testVariablize()
    {
        $this->assertEquals('customerTable', Inflector::variablize('customer_table'));
        $this->assertEquals('„Å≤„Çâ„Åå„Å™Hepimiz', Inflector::variablize('„Å≤„Çâ„Åå„Å™_hepimiz'));
    }

    public function testTableize()
    {
        $this->assertEquals('customer_tables', Inflector::tableize('customerTable'));
    }

    public function testSlugCommons()
    {
        $data = [
            '' => '',
            'hello world 123' => 'hello-world-123',
            'remove.!?[]{}‚Ä¶symbols' => 'removesymbols',
            'minus-sign' => 'minus-sign',
            'mdash‚Äîsign' => 'mdash-sign',
            'ndash‚Äìsign' => 'ndash-sign',
            '√°√†√¢√©√®√™√≠√¨√Æ√≥√≤√¥√∫√π√ª√£' => 'aaaeeeiiiooouuua',
            '√§l√§ ly√∂ √§√§li√∂ √∂√∂li√§ l√§ikkyy' => 'ala-lyo-aalio-oolia-laikkyy',
        ];

        foreach ($data as $source => $expected) {
            if (extension_loaded('intl')) {
                $this->assertEquals($expected, FallbackInflector::slug($source));
            }
            $this->assertEquals($expected, Inflector::slug($source));
        }
    }

    public function testSlugReplacements()
    {
        $this->assertEquals('dont_replace_replacement', Inflector::slug('dont replace_replacement', '_'));
        $this->assertEquals('remove_trailing_replacements', Inflector::slug('_remove trailing replacements_', '_'));
        $this->assertEquals('thisrepisrepreplacement', Inflector::slug('this is REP-lacement', 'REP'));
    }

    public function testSlugIntl()
    {
        if (!extension_loaded('intl')) {
            $this->markTestSkipped('intl extension is required.');
        }

        // Some test strings are from https://github.com/bergie/midgardmvc_helper_urlize. Thank you, Henri Bergius!
        $data = [
            // Korean
            'Ìï¥ÎèôÍ≤ÄÎèÑ' => 'haedong-geomdo',
            // Hiragana
            '„Å≤„Çâ„Åå„Å™' => 'hiragana',
            // Georgian
            '·É°·Éê·É•·Éê·É†·Éó·Éï·Éî·Éö·Éù' => 'sakartvelo',
            // Arabic
            'ÿßŸÑÿπÿ±ÿ®Ÿä' => 'alrby',
            'ÿπÿ±ÿ®' => 'rb',
            // Hebrew
            '◊¢÷¥◊ë÷∞◊®÷¥◊ô◊™' => 'iberiyt',
            // Turkish
            'Sanƒ±rƒ±m hepimiz aynƒ± ≈üeyi d√º≈ü√ºn√ºyoruz.' => 'sanirim-hepimiz-ayni-seyi-dusunuyoruz',
            // Russian
            '–Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å' => 'nedvizimost',
            '–ö–æ–Ω—Ç–∞–∫—Ç—ã' => 'kontakty',
            // Chinese
            'ÁæéÂõΩ' => 'mei-guo',
            // Estonian
            'J√§√§√§r' => 'jaaar',
        ];

        foreach ($data as $source => $expected) {
            $this->assertEquals($expected, Inflector::slug($source));
        }
    }

    public function testTransliterateStrict()
    {
        if (!extension_loaded('intl')) {
            $this->markTestSkipped('intl extension is required.');
        }

        // Some test strings are from https://github.com/bergie/midgardmvc_helper_urlize. Thank you, Henri Bergius!
        $data = [
            // Korean
            'Ìï¥ÎèôÍ≤ÄÎèÑ' => 'haedong-geomdo',
            // Hiragana
            '„Å≤„Çâ„Åå„Å™' => 'hiragana',
            // Georgian
            '·É°·Éê·É•·Éê·É†·Éó·Éï·Éî·Éö·Éù' => 'sakartvelo',
            // Arabic
            'ÿßŸÑÿπÿ±ÿ®Ÿä' => 'aÃ£l ørby',
            'ÿπÿ±ÿ®' => ' ørb',
            // Hebrew
            '◊¢÷¥◊ë÷∞◊®÷¥◊ô◊™' => ' ªibeÃÜriytÃß',
            // Turkish
            'Sanƒ±rƒ±m hepimiz aynƒ± ≈üeyi d√º≈ü√ºn√ºyoruz.' => 'Sanƒ±rƒ±m hepimiz aynƒ± sÃßeyi duÃàsÃßuÃànuÃàyoruz.',

            // Russian
            '–Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å' => 'nedvizÃåimost π',
            '–ö–æ–Ω—Ç–∞–∫—Ç—ã' => 'Kontakty',

            // Ukrainian
            '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞: “ë–∞–Ω–æ–∫, —î–≤—Ä–æ–ø–∞' => 'UkraiÃÅÃàns πka: gÃÄanok, eÃÇvropa',

            // Serbian
            '–°—Ä–ø—Å–∫–∞: —í, —ö, —ü!' => 'Srpska: ƒë, nÃÇ, dÃÇ!',

            // Spanish
            '¬øEspa√±ol?' => '¬øEspanÃÉol?',
            // Chinese
            'ÁæéÂõΩ' => 'meÃåi guoÃÅ',
        ];

        foreach ($data as $source => $expected) {
            $this->assertEquals($expected, Inflector::transliterate($source, Inflector::TRANSLITERATE_STRICT));
        }
    }

    public function testTransliterateMedium()
    {
        if (!extension_loaded('intl')) {
            $this->markTestSkipped('intl extension is required.');
        }

        // Some test strings are from https://github.com/bergie/midgardmvc_helper_urlize. Thank you, Henri Bergius!
        $data = [
            // Korean
            'Ìï¥ÎèôÍ≤ÄÎèÑ' => ['haedong-geomdo'],
            // Hiragana
            '„Å≤„Çâ„Åå„Å™' => ['hiragana'],
            // Georgian
            '·É°·Éê·É•·Éê·É†·Éó·Éï·Éî·Éö·Éù' => ['sakartvelo'],
            // Arabic
            'ÿßŸÑÿπÿ±ÿ®Ÿä' => ['al ørby'],
            'ÿπÿ±ÿ®' => [' ørb'],
            // Hebrew
            '◊¢÷¥◊ë÷∞◊®÷¥◊ô◊™' => ['\'iberiyt', ' ªiberiyt'],
            // Turkish
            'Sanƒ±rƒ±m hepimiz aynƒ± ≈üeyi d√º≈ü√ºn√ºyoruz.' => ['Sanirim hepimiz ayni seyi dusunuyoruz.'],

            // Russian
            '–Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å' => ['nedvizimost\'', 'nedvizimost π'],
            '–ö–æ–Ω—Ç–∞–∫—Ç—ã' => ['Kontakty'],

            // Ukrainian
            '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞: “ë–∞–Ω–æ–∫, —î–≤—Ä–æ–ø–∞' => ['Ukrains πka: ganok, evropa', 'Ukrains\'ka: ganok, evropa'],

            // Serbian
            '–°—Ä–ø—Å–∫–∞: —í, —ö, —ü!' => ['Srpska: d, n, d!'],

            // Spanish
            '¬øEspa√±ol?' => ['¬øEspanol?'],
            // Chinese
            'ÁæéÂõΩ' => ['mei guo'],
        ];

        foreach ($data as $source => $allowed) {
            $this->assertIsOneOf(Inflector::transliterate($source, Inflector::TRANSLITERATE_MEDIUM), $allowed);
        }
    }

    public function testTransliterateLoose()
    {
        if (!extension_loaded('intl')) {
            $this->markTestSkipped('intl extension is required.');
        }

        // Some test strings are from https://github.com/bergie/midgardmvc_helper_urlize. Thank you, Henri Bergius!
        $data = [
            // Korean
            'Ìï¥ÎèôÍ≤ÄÎèÑ' => ['haedong-geomdo'],
            // Hiragana
            '„Å≤„Çâ„Åå„Å™' => ['hiragana'],
            // Georgian
            '·É°·Éê·É•·Éê·É†·Éó·Éï·Éî·Éö·Éù' => ['sakartvelo'],
            // Arabic
            'ÿßŸÑÿπÿ±ÿ®Ÿä' => ['alrby'],
            'ÿπÿ±ÿ®' => ['rb'],
            // Hebrew
            '◊¢÷¥◊ë÷∞◊®÷¥◊ô◊™' => ['\'iberiyt', 'iberiyt'],
            // Turkish
            'Sanƒ±rƒ±m hepimiz aynƒ± ≈üeyi d√º≈ü√ºn√ºyoruz.' => ['Sanirim hepimiz ayni seyi dusunuyoruz.'],

            // Russian
            '–Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å' => ['nedvizimost\'', 'nedvizimost'],
            '–ö–æ–Ω—Ç–∞–∫—Ç—ã' => ['Kontakty'],

            // Ukrainian
            '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞: “ë–∞–Ω–æ–∫, —î–≤—Ä–æ–ø–∞' => ['Ukrainska: ganok, evropa', 'Ukrains\'ka: ganok, evropa'],

            // Serbian
            '–°—Ä–ø—Å–∫–∞: —í, —ö, —ü!' => ['Srpska: d, n, d!'],

            // Spanish
            '¬øEspa√±ol?' => ['Espanol?'],
            // Chinese
            'ÁæéÂõΩ' => ['mei guo'],
        ];

        foreach ($data as $source => $allowed) {
            $this->assertIsOneOf(Inflector::transliterate($source, Inflector::TRANSLITERATE_LOOSE), $allowed);
        }
    }

    public function testSlugPhp()
    {
        $data = [
            'we have –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å' => 'we-have',
        ];

        foreach ($data as $source => $expected) {
            $this->assertEquals($expected, FallbackInflector::slug($source));
        }
    }

    public function testClassify()
    {
        $this->assertEquals('CustomerTable', Inflector::classify('customer_tables'));
    }

    public function testOrdinalize()
    {
        $this->assertEquals('21st', Inflector::ordinalize('21'));
        $this->assertEquals('22nd', Inflector::ordinalize('22'));
        $this->assertEquals('23rd', Inflector::ordinalize('23'));
        $this->assertEquals('24th', Inflector::ordinalize('24'));
        $this->assertEquals('25th', Inflector::ordinalize('25'));
        $this->assertEquals('111th', Inflector::ordinalize('111'));
        $this->assertEquals('113th', Inflector::ordinalize('113'));
    }

    public function testSentence()
    {
        $array = [];
        $this->assertEquals('', Inflector::sentence($array));

        $array = ['Spain'];
        $this->assertEquals('Spain', Inflector::sentence($array));

        $array = ['Spain', 'France'];
        $this->assertEquals('Spain and France', Inflector::sentence($array));

        $array = ['Spain', 'France', 'Italy'];
        $this->assertEquals('Spain, France and Italy', Inflector::sentence($array));

        $array = ['Spain', 'France', 'Italy', 'Germany'];
        $this->assertEquals('Spain, France, Italy and Germany', Inflector::sentence($array));

        $array = ['Spain', 'France'];
        $this->assertEquals('Spain or France', Inflector::sentence($array, ' or '));

        $array = ['Spain', 'France', 'Italy'];
        $this->assertEquals('Spain, France or Italy', Inflector::sentence($array, ' or '));

        $array = ['Spain', 'France'];
        $this->assertEquals('Spain and France', Inflector::sentence($array, ' and ', ' or ', ' - '));

        $array = ['Spain', 'France', 'Italy'];
        $this->assertEquals('Spain - France or Italy', Inflector::sentence($array, ' and ', ' or ', ' - '));
    }
}
